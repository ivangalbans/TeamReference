/*
        task:           Finding the number of Hamiltonian walks in the
                        unweighted and directed graph G = (V, E).
        complexity:     O(2^n * n^2)
        notes:          Let dp[msk][v] be the amount of Hamiltonian walks
                        on the subgraph generated by vertices in msk that
                        end in the vertex v.
*/
#define BIT(n) (1 << n)
const int MAXN = 20;

int n, m, u, v, g[MAXN], dp[BIT(MAXN)][MAXN], ans;

int main() {
  cin >> n >> m;

  for (int i = 0; i < m; ++i) {
    cin >> u >> v;
    g[u] |= BIT(v);
  }

  for (int i = 0; i < n; ++i)
    dp[BIT(i)][i] = 1;

  for (int msk = 1; msk < BIT(n); ++msk) {
    for (int i = 0; i < n; ++i)
      if (msk & BIT(i)) {
        int tmsk = msk ^ BIT(i);

        for (int j = 0; tmsk && j < n; ++j) {
          if (g[j] & BIT(i))
            dp[msk][i] += dp[tmsk][j];
        }
      }
  }
  for (int i = 0; i < n; ++i)
    ans += dp[BIT(n) - 1][i];
  cout << ans << endl;
  return 0;
}
