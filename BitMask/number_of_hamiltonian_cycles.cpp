/*
        task:           Finding the number of Hamiltonian cycles in
                        the unweighted and directed graph G = (V, E).

        complexity:     O(2^n * n^2)

        notes:          Let dp[msk][v] be the amount of Hamiltonian walks
                        on the subgraph generated by vertices in msk that
                        begin in vertex 0 and end in vertex v.
*/

#define BIT(n) (1 << n)
const int MAXN = 20;

int n, m, u, v, ans, g[MAXN], dp[BIT(MAXN)][MAXN];

int main() {
  cin >> n >> m;

  for (int i = 0; i < m; ++i) {
    cin >> u >> v;
    g[u] |= (1 << v);
  }

  dp[1][0] = 1;

  for (int msk = 2; msk < BIT(n); ++msk) {
    for (int i = 0; i < n; ++i)
      if (msk & BIT(i)) {
        int tmsk = msk ^ BIT(i);

        for (int j = 0; tmsk && j < n; ++j)
          if (g[j] & BIT(i))
            dp[msk][i] += dp[tmsk][j];
      }
  }

  for (int i = 1; i < n; ++i)
    if (g[i] & 1)
      ans += dp[BIT(n) - 1][i];

  cout << ans << endl;
  return 0;
}
