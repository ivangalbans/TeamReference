/*
        task:           Search for the shortest Hamiltonian walk.
                        Let the directed graph G = (V, E) have n
                        vertices, and each edge have weight d(i, j).
                        We want to find a Hamiltonian walk for which
                        the sum of weights of its edges is minimal.

        complexity:     O(2^n * n^2)

        notes:          Let dp[msk][v] be the length of the shortest
                        Hamiltonian walk on the subgraph generated by
                        vertices in msk that end in vertex v.
*/

#define MAXN 20
#define INF 0x1fffffff
#define BIT(n) (1 << n)

using namespace std;

int n, m, ans = INF, d[MAXN][MAXN], u, v, w, dp[1 << MAXN][MAXN];

int main() {
  cin >> n >> m;

  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n; ++j)
      d[i][j] = INF;
  }

  for (int i = 0; i < BIT(n); ++i) {
    for (int j = 0; j < n; ++j)
      dp[i][j] = INF;
  }

  for (int i = 0; i < m; ++i) {
    cin >> u >> v >> w;
    d[u][v] = w;
  }

  for (int i = 0; i < n; ++i)
    dp[1 << i][i] = 0;

  for (int msk = 1; msk < (1 << n); ++msk) {
    for (int i = 0; i < n; ++i)
      if (msk & BIT(i)) {
        int tmsk = msk ^ BIT(i);

        for (int j = 0; tmsk && j < n; ++j)
          dp[msk][i] = min(dp[tmsk][j] + d[j][i], dp[msk][i]);
      }
  }

  for (int i = 0; i < n; ++i)
    ans = min(ans, dp[BIT(n) - 1][i]);

  cout << ans << endl;
  return 0;
}
